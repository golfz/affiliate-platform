package main

import (
	"context"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"

	_ "github.com/jonosize/affiliate-platform/docs" // swagger docs (generated by swag init)
	"github.com/jonosize/affiliate-platform/internal/api"
	"github.com/jonosize/affiliate-platform/internal/config"
	"github.com/jonosize/affiliate-platform/internal/database"
	"github.com/jonosize/affiliate-platform/internal/logger"
	"github.com/jonosize/affiliate-platform/internal/worker"
)

// @title Jenosize Affiliate Platform API
// @version 1.0
// @description API for affiliate link generation and price comparison
// @host localhost:8080
// @BasePath /api
func main() {
	// Load configuration
	configPath := os.Getenv("CONFIG_PATH")
	if configPath == "" {
		configPath = "./configs"
	}
	cfg := config.LoadOrPanic(configPath)

	// Initialize logger
	if err := logger.Init("info"); err != nil {
		panic("failed to initialize logger: " + err.Error())
	}
	defer func() {
		_ = logger.Get().Sync() // Ignore error on sync
	}()

	log := logger.Get()
	log.Info("Starting application...")

	// Initialize database
	db, err := database.InitGORM(cfg)
	if err != nil {
		log.Fatal("Failed to initialize database", logger.Error(err))
	}
	defer func() {
		if err := db.Close(); err != nil {
			log.Error("Error closing database", logger.Error(err))
		}
	}()

	log.Info("Database initialized successfully")

	// Initialize price refresh worker
	priceRefreshWorker := worker.NewPriceRefreshWorker(db, cfg, log)
	if err := priceRefreshWorker.Start(); err != nil {
		log.Fatal("Failed to start price refresh worker", logger.Error(err))
	}
	defer priceRefreshWorker.Stop()

	log.Info("Price refresh worker started")

	// Initialize Echo
	e := echo.New()
	e.HideBanner = true

	// Middleware
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// CORS: Always send CORS headers on ALL responses
	e.Use(func(next echo.HandlerFunc) echo.HandlerFunc {
		return func(c echo.Context) error {
			// ALWAYS set CORS headers - no exceptions
			c.Response().Header().Set("Access-Control-Allow-Origin", "*")
			c.Response().Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, PATCH, OPTIONS")
			c.Response().Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, Accept, Origin, X-Requested-With")
			c.Response().Header().Set("Access-Control-Max-Age", "86400")

			// Handle OPTIONS preflight requests - return 204 with CORS headers
			if c.Request().Method == echo.OPTIONS {
				return c.NoContent(http.StatusNoContent) // 204 is correct for OPTIONS
			}

			return next(c)
		}
	})
	e.Use(middleware.Logger())
	e.Use(middleware.Recover())

	// Swagger route
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// Health check route (public)
	e.GET("/health", healthCheck)

	// Setup API routes
	api.SetupRoutes(e, db, cfg, log, priceRefreshWorker)

	// Start server in a goroutine
	port := cfg.GetServerPort()
	if port == "" {
		port = "8080"
	}
	addr := cfg.GetServerHost() + ":" + port

	go func() {
		log.Info("Server starting", logger.String("address", addr))
		if err := e.Start(addr); err != nil && err != http.ErrServerClosed {
			log.Fatal("Failed to start server", logger.Error(err))
		}
	}()

	// Wait for interrupt signal to gracefully shutdown the server
	quit := make(chan os.Signal, 1)
	signal.Notify(quit, os.Interrupt, syscall.SIGTERM)
	<-quit

	log.Info("Shutting down server...")

	// Create shutdown context with timeout
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	// Shutdown Echo server
	if err := e.Shutdown(ctx); err != nil {
		log.Fatal("Server forced to shutdown", logger.Error(err))
	}

	log.Info("Server exited gracefully")
}

// healthCheck is a simple health check endpoint
func healthCheck(c echo.Context) error {
	return c.JSON(http.StatusOK, map[string]interface{}{
		"status":    "ok",
		"timestamp": time.Now().UTC().Format(time.RFC3339),
	})
}
